---
需求名称: CC-Workflow工程化约束增强
需求类型: software-feature
创建时间: 2026-02-22
当前阶段: P1
风险等级: 中
版本: v1.1
---

# P1-需求文档：CC-Workflow 工程化约束增强

## 一、需求背景

### 1.1 现状分析

CC-Workflow 是一个以 Claude Code 为中心的团队工作流框架，采用 Skill + Agent 分离架构，实现从需求到上线的 16 阶段全流程自动化。当前架构的核心特点如下：

| 维度 | 当前实现 |
|------|----------|
| 流程框架 | 16 阶段（P1-P16），覆盖完整产品生命周期 |
| 角色定义 | 6 个 Agent（pm、analyst、architect、dev、qa、tech-writer） |
| 流程规范 | 11 个 Skill，定义阶段目标、输入输出、检查清单 |
| 上下文隔离 | 故事文件机制（P5 生成，P9 使用） |
| 文档中心 | Obsidian vault（docs/ 目录） |

同期调研的开源项目 **Trellis**（2 天 1k star）提供了另一种 AI Coding 框架设计思路，其核心机制包括：

| 机制 | 实现方式 |
|------|----------|
| Hook 自动注入 | `inject-subagent-context.py` 在 PreToolUse 时自动注入上下文 |
| Ralph Loop | `ralph-loop.py` 控制检查 Agent 完成条件，最多 5 次循环 |
| jsonl 配置 | 每个任务通过 `.jsonl` 文件定义所需上下文文件 |
| Worktree 隔离 | Git Worktree 实现物理隔离开发 |
| CLI 工具 | `trellis init`、`trellis update` 命令管理项目配置 |

### 1.2 问题陈述

经过深入对比分析，当前 CC-Workflow 存在以下核心问题：

**问题 1：Agent 调用机制缺陷**

当前 Skill 中采用注释标记方式让大模型"扮演"对应角色，而非真正调用独立的子 Agent。具体表现为：

```markdown
<!-- AGENT: dev -->
你现在扮演开发工程师角色。请阅读 `.claude/agents/dev.md` 了解...
<!-- END AGENT -->
```

该方式存在以下缺陷：
- 角色切换不彻底，大模型仍保持原有上下文
- 无法实现真正的上下文隔离
- 无法利用 Claude Code 的 Task 工具进行子 Agent 调用

**问题 2：缺乏 Worktree 隔离机制**

当前未集成 Git Worktree 功能，导致：
- 多个需求同时进行时存在冲突风险
- 无法实现需求级别的物理隔离
- 缺乏独立的环境文件复制和初始化机制

**问题 3：软约束执行**

当前采用文档软约束方式，缺乏确定性执行保障：
- 规范依赖 AI 遵循文档指令，无强制执行机制
- 上下文加载依赖 AI 主动读取故事文件
- 质量控制依赖流程规范而非程序化验证

**问题 4：缺乏程序化质量控制**

当前检查阶段（如 ideal-code-review）依赖 Skill 定义的检查清单，缺乏：
- 自动运行的验证命令（lint、typecheck、test）
- 循环验证机制（失败时自动重试）
- 完成条件的程序化判断

### 1.3 目标概述

本需求旨在将 **Trellis 的工程化约束机制** 融入 **CC-Workflow 的企业流程框架**，实现以下核心目标：

| 目标 | 说明 |
|------|------|
| 修复 Agent 调用机制 | 从"角色扮演"改为真正的子 Agent 调用（Task 工具） |
| 引入细粒度 Agent | 新增 implement、check、debug、research 四个 Agent |
| 添加 Worktree 隔离 | P1 阶段创建 Worktree，需求之间彻底隔离 |
| 引入工程化约束机制 | Hook 自动注入、Ralph Loop 质量控制、jsonl 上下文配置 |
| 保留差异化优势 | 16 阶段企业流程、Skill + Agent 分离、Obsidian 集成 |
| CLI 工具化 | 提供 init、update 等命令，提升易用性 |

---

## 二、目标用户

| 用户角色 | 使用场景 | 核心需求 |
|----------|----------|----------|
| 开发工程师 | 日常开发、代码审查、调试 | 确定性的开发流程、可靠的质量保障、并行开发能力 |
| 产品经理 | 需求编写、进度跟踪 | 清晰的流程状态、自动化的文档生成 |
| 技术负责人 | 架构评审、技术决策 | 可追溯的开发记录、规范化的输出质量 |
| 测试工程师 | 测试用例编写、测试执行 | 自动化的测试验证、明确的验收标准 |

---

## 三、功能需求

### 3.1 功能清单

| 功能编号 | 功能名称 | 功能描述 | 优先级 |
|----------|----------|----------|--------|
| F001 | 子 Agent 调用机制 | 使用 Task 工具实现真正的子 Agent 调用，替代注释扮演方式 | P0 |
| F002 | 新增细粒度 Agent | 新增 implement、check、debug、research 四个 Agent | P0 |
| F003 | Hook 自动注入 | PreToolUse Hook 在子 Agent 调用前自动注入上下文 | P0 |
| F004 | jsonl 上下文配置 | 为每个故事定义所需上下文文件，位于故事文件同级 | P0 |
| F005 | Ralph Loop 质量控制 | SubagentStop Hook 控制 Check Agent 完成条件，集成到 P9 | P0 |
| F006 | Worktree 生命周期管理 | P1 创建 Worktree，代码合并后删除 | P0 |
| F007 | 现有 Skill 全面重构 | 所有 Skill 改用 Task 工具调用子 Agent | P0 |
| F008 | worktree.yaml 配置 | 定义 Worktree 目录、复制文件、初始化命令、验证命令 | P1 |
| F009 | CLI 工具 | `ideal init`、`ideal update` 等命令管理项目配置 | P1 |
| F010 | 版本迁移机制 | CLI 更新时处理文件重命名和删除，保护用户修改 | P2 |

### 3.2 功能详细说明

#### F001：子 Agent 调用机制

**当前问题：** Skill 使用注释标记让当前大模型"扮演"角色

**目标方案：** 使用 Claude Code 的 Task 工具调用子 Agent

```python
# Skill 中调用子 Agent
Task(
  subagent_type: "implement",
  prompt: "实现 001-基础模块故事",
  model: "opus",
  run_in_background: true
)
```

**实现要点：**
- Skill 内部实现调度逻辑（不引入独立的 Dispatch Agent）
- 根据故事依赖关系判断是否并行执行
- 调用对应的子 Agent（implement、check、debug、research）

#### F002：新增细粒度 Agent

**新增 Agent 清单：**

| Agent | 职责 | 禁止操作 |
|-------|------|----------|
| **implement** | 纯代码实现 | git commit、git push |
| **check** | 代码检查、自我修复 | - |
| **debug** | 深度调试、根因分析 | - |
| **research** | 纯研究、不修改文件 | 任何文件修改 |

**现有 Agent 职责调整：**

| Agent | 原职责 | 新职责 |
|-------|--------|--------|
| dev | 代码实现、TDD 开发 | 调度 implement/check/debug 子 Agent |
| pm | 需求梳理 | 不变 |
| analyst | 竞品分析 | 不变 |
| architect | 架构设计 | 不变 |
| qa | 测试相关 | 不变 |
| tech-writer | 文档编写 | 不变 |

**Agent 总数：** 6（原有） + 4（新增） = 10 个

#### F003：Hook 自动注入

**触发时机：** PreToolUse - Task 工具调用前

**核心逻辑：**
1. 检测 subagent_type（implement、check、debug、research）
2. 读取 `.current-task` 定位当前需求目录
3. 读取对应的 jsonl 文件
4. 注入所有文件内容到子 Agent 的 prompt

**参考实现：** Trellis 的 `inject-subagent-context.py`

#### F004：jsonl 上下文配置

**文件位置：** 故事文件同级

```
docs/迭代/{需求}/stories/
├── index.md                    # 故事索引 + 依赖关系
├── 001-基础模块.md             # 故事内容
├── 001-基础模块.jsonl          # 上下文配置
├── 002-API层.md
├── 002-API层.jsonl
└── ...
```

**格式定义：**
```jsonl
{"file": ".claude/skills/ideal-dev-exec/SKILL.md", "reason": "开发执行规范"}
{"file": ".claude/agents/implement.md", "reason": "实现 Agent 定义"}
{"file": "docs/迭代/{需求}/P3-技术方案.md", "section": "F001实现", "reason": "技术设计"}
{"file": "src/", "type": "directory", "pattern": "*.ts", "reason": "代码参考"}
```

**字段说明：**
- `file`：文件或目录路径
- `type`：可选，`directory` 表示加载目录下所有匹配文件
- `pattern`：可选，文件匹配模式
- `reason`：加载原因，用于生成完成标记

#### F005：Ralph Loop 质量控制

**触发时机：** SubagentStop - Check Agent 尝试停止时

**应用阶段：** P9（ideal-dev-exec Skill）

**核心逻辑：**
1. 检查 worktree.yaml 的 verify 命令配置
2. 执行验证命令（pnpm lint、pnpm typecheck、pnpm test）
3. 全部通过 → 允许停止
4. 任一失败 → 阻止停止，要求继续修复
5. 最多 5 次循环，防止无限循环

**参考实现：** Trellis 的 `ralph-loop.py`

#### F006：Worktree 生命周期管理

**生命周期流程：**

```
P1 需求编写
    └── 创建 Worktree: feature/{需求名称}

P2-P13 在 Worktree 中工作
    └── 各阶段产出物提交到 Worktree 分支

P14 部署上线前
    ├── 代码合并到主分支
    └── 删除 Worktree

P15-P16 在主仓库完成
    └── 维基更新不需要代码隔离
```

**创建 Worktree（P1）：**
```bash
# 1. 创建 Worktree
git worktree add ../ideal-worktrees/feature/{需求名称} -b feature/{需求名称}

# 2. 复制环境文件
cp .env ../ideal-worktrees/feature/{需求名称}/
cp .ideal/.developer ../ideal-worktrees/feature/{需求名称}/.ideal/

# 3. 执行初始化命令
cd ../ideal-worktrees/feature/{需求名称}
pnpm install --frozen-lockfile
```

**删除 Worktree（P14 代码合并后）：**
```bash
# 1. 确认代码已合并
git log main..feature/{需求名称} --oneline

# 2. 删除 Worktree
git worktree remove ../ideal-worktrees/feature/{需求名称}

# 3. 删除分支（可选）
git branch -d feature/{需求名称}
```

#### F007：现有 Skill 全面重构

**重构原则：**
1. 去掉 `<!-- AGENT: xxx -->` 注释扮演方式
2. 使用 Task 工具调用对应的子 Agent
3. 调度逻辑在 Skill 内部实现

**需要重构的 Skill 清单：**

| Skill | 原调用方式 | 新调用方式 |
|-------|-----------|-----------|
| ideal-requirement | 注释扮演 pm/analyst | Task(subagent_type="pm") |
| ideal-dev-solution | 注释扮演 architect | Task(subagent_type="architect") |
| ideal-dev-plan | 注释扮演 architect/pm | Task(subagent_type="architect") |
| ideal-test-case | 注释扮演 qa | Task(subagent_type="qa") |
| ideal-dev-exec | 注释扮演 dev | Task(subagent_type="implement/check/debug") |
| ideal-code-review | 注释扮演 dev/architect | Task(subagent_type="check") |
| ideal-test-exec | 注释扮演 qa/dev | Task(subagent_type="qa") |
| ideal-wiki | 注释扮演 tech-writer | Task(subagent_type="tech-writer") |
| ideal-debugging | 注释扮演 dev | Task(subagent_type="debug") |
| ideal-flow-control | 无 Agent 调用 | 不变 |

#### F008：worktree.yaml 配置

**配置文件位置：** `.ideal/worktree.yaml`

**配置项：**
```yaml
# Worktree 存储目录（相对于项目根目录）
worktree_dir: ../ideal-worktrees

# 需要复制到 Worktree 的环境文件
copy:
  - .env
  - .ideal/.developer

# Worktree 创建后执行的初始化命令
post_create:
  - pnpm install --frozen-lockfile

# 验证命令（Ralph Loop 使用）
verify:
  - pnpm lint
  - pnpm typecheck
  - pnpm test
```

#### F009：CLI 工具

**命令清单：**

| 命令 | 功能 |
|------|------|
| `ideal init` | 初始化项目结构（.ideal/ 目录、配置文件、Hook 脚本） |
| `ideal update` | 更新模板文件和 Hook 脚本到最新版本 |
| `ideal worktree list` | 列出所有 Worktree |
| `ideal worktree create <需求名>` | 手动创建 Worktree |
| `ideal worktree remove <需求名>` | 手动删除 Worktree |

---

## 四、Agent 架构（更新后）

### 4.1 Agent 清单

| Agent | 职责 | 来源 | 被调用阶段 |
|-------|------|------|-----------|
| pm | 需求梳理、产品决策 | 保留 | P1, P5 |
| analyst | 竞品分析、市场调研 | 保留 | P1 |
| architect | 架构设计、技术方案 | 保留 | P3, P5 |
| dev | 调度 implement/check/debug | 保留（职责调整） | P9 |
| qa | 测试设计、用例编写 | 保留 | P7, P11 |
| tech-writer | 文档编写 | 保留 | P15 |
| **implement** | 纯代码实现 | 新增 | P9 |
| **check** | 代码检查、自我修复 | 新增 | P9 |
| **debug** | 深度调试、根因分析 | 新增 | P9 |
| **research** | 纯研究、不修改文件 | 新增 | 任意阶段 |

### 4.2 Agent 调用关系

```
P9 ideal-dev-exec Skill
    │
    ├── Task(subagent_type="implement")  → 实现代码
    │
    ├── Task(subagent_type="check")      → 检查代码（Ralph Loop 控制）
    │       │
    │       └── 验证失败 → Task(subagent_type="debug") → 调试修复
    │
    └── 并行故事 → 多个 implement 同时执行
```

---

## 五、非功能需求

| 维度 | 要求 |
|------|------|
| 性能 | Hook 注入延迟 < 500ms；验证命令超时 120s/命令 |
| 可用性 | CLI 命令提供友好提示；错误信息清晰可操作 |
| 安全性 | Worktree 创建前验证路径安全；不覆盖未提交的修改 |
| 兼容性 | 保持与现有 16 阶段流程的兼容；全面重构 Skill |

---

## 六、约束条件

| 约束类型 | 说明 |
|----------|------|
| 技术约束 | 必须使用 Claude Code 的 Hook 机制（PreToolUse、SubagentStop）；Hook 脚本使用 Python |
| 时间约束 | 分阶段实施：P0 功能优先，P1/P2 功能后续迭代 |
| 资源约束 | Agent 从 6 个扩展到 10 个；现有 Skill 全面重构 |

---

## 七、验收标准

### 7.1 功能验收

**子 Agent 调用机制：**
- [ ] Skill 调用子 Agent 时使用 Task 工具而非注释扮演
- [ ] implement Agent 可实现代码，禁止执行 git commit
- [ ] check Agent 可检查代码并自我修复
- [ ] debug Agent 可进行深度调试和根因分析
- [ ] research Agent 可进行研究，禁止修改任何文件

**Hook 自动注入：**
- [ ] PreToolUse Hook 在子 Agent 调用前自动注入 jsonl 配置的上下文
- [ ] jsonl 文件位于故事文件同级（`{故事名}.jsonl`）

**Ralph Loop 质量控制：**
- [ ] SubagentStop Hook 在验证失败时阻止 Check Agent 停止
- [ ] 验证命令（lint、typecheck、test）全部通过后才允许 Check 阶段结束
- [ ] 最多循环 5 次，防止无限循环

**Worktree 生命周期：**
- [ ] P1 阶段自动创建 Worktree
- [ ] Worktree 自动复制环境文件、执行初始化命令
- [ ] P14 代码合并后自动删除 Worktree

**Skill 重构：**
- [ ] 所有 Skill 改用 Task 工具调用子 Agent
- [ ] 去掉所有 `<!-- AGENT: xxx -->` 注释扮演方式

**CLI 工具：**
- [ ] `ideal init` 命令可初始化项目结构
- [ ] `ideal update` 命令可更新模板文件
- [ ] `ideal worktree list/create/remove` 命令可用

### 7.2 非功能验收

- [ ] Hook 注入对用户透明，无需手动干预
- [ ] 错误信息包含具体原因和操作建议
- [ ] 文档更新完整，包含新机制的使用说明

---

## 八、风险评估

| 风险项 | 影响程度 | 发生概率 | 应对措施 |
|--------|----------|----------|----------|
| Hook 机制学习成本 | 中 | 高 | 参考 Trellis 实现，编写详细文档 |
| Skill 全面重构工作量大 | 高 | 高 | 分阶段实施，优先重构核心 Skill |
| Worktree 路径冲突 | 低 | 中 | 自动检测并提示用户选择 |
| 循环验证无限循环 | 中 | 低 | 设置最大循环次数（5 次）和超时（30 分钟） |
| Agent 数量增加导致管理复杂 | 中 | 中 | 明确 Agent 职责边界，编写调用规范 |

---

## 九、参考资料

1. **Trellis 项目** - https://github.com/mindfold-ai/Trellis
   - Hook 机制实现：`src/templates/claude/hooks/inject-subagent-context.py`
   - Ralph Loop 实现：`src/templates/claude/hooks/ralph-loop.py`
   - Agent 定义：`src/templates/claude/agents/`
   - 工作流指南：`docs/guide.md`

2. **CC-Workflow 现有架构**
   - Skill 定义：`.claude/skills/*/SKILL.md`
   - Agent 定义：`.claude/agents/*.md`
   - 流程状态：`docs/迭代/*/流程状态.md`

3. **Claude Code 文档**
   - Hooks 机制：PreToolUse、SubagentStop 事件
   - Task 工具：子 Agent 调用方式

---

*文档版本: v1.1*
*创建时间: 2026-02-22*
*更新时间: 2026-02-22*
*作者: Claude Code*
